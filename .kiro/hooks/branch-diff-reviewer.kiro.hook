{
  "enabled": true,
  "name": "Branch Diff Reviewer",
  "description": "Reviews all code changes between the current branch and main branch, analyzing for code smells, design patterns, best practices, readability, maintainability, and performance improvements.",
  "version": "1",
  "when": {
    "type": "userTriggered"
  },
  "then": {
    "type": "askAgent",
    "prompt": "You are an expert software engineer reviewing code changes. Compare the current git HEAD state with the main branch and analyze all modified code.\n\n**Step 1**: List all of the file that have been changed between the main branch and the current branch.\n\n**Step 2**: Analyze the changes focusing on the issues that are being added with the changes not the existing one:\n\n1. DRY & Reuse Checks (Fail‑fast)\n\n1.1 Exact/near-duplicate detection:\n- Search repo for similar classes/functions/regexes/AST shapes; flag any reimplementation of an existing utility, helper, adapter, or pattern.\nIf duplication found, name the existing artifact and propose replacement/refactor (e.g., “replace new DateRangeParser with existing date-range.ts:parseRange()”).\n- Missed reuse of shared utilities/patterns:\n- Check if the new code should use existing utilities, adapters, error types, logging, config loaders, validation schemas, DTOs, i18n, feature flags, caching, retry/backoff, or concurrency helpers already in the repo.\nIf a recognized pattern exists (Repository, Strategy, Adapter, Middleware), require alignment with its established shape (folder, naming, public API).\n\n\nSingle Source of Truth:\n\nVerify constants, types, schema definitions, and feature flags are not redefined; reference central modules.\n\n\nCross-cutting concerns:\n\nEnsure new code plugs into existing logging/telemetry, error taxonomy, input validation, and configuration mechanisms (no bespoke copies).\n\n\n\n2. Integration with Existing Codebase\n\nDependency fit: Confirm new modules are imported via the established public surface (index barrel, package boundary) and respect layering/DDD boundaries (no domain leakage).\nCompatibility: Validate types/contracts with upstream/downstream consumers; check runtime wiring (DI container, module registration, routing, feature flag).\nMigration path: If a replacement is intended, require deprecation notes, redirection, and tests proving old paths are covered or removed.\n\n1. **Code Smells**: Identify any code smells such as:\n   - Duplicated code\n   - Long methods (>50 lines)\n   - Large classes (>300 lines)\n   - Excessive parameters (>4)\n   - Inappropriate intimacy between classes\n   - Feature envy\n   - Data clumps\n\n2. **Design Patterns**: Suggest applicable design patterns that could improve:\n   - Code structure\n   - Maintainability\n   - Extensibility\n   - Testability\n\n3. **Best Practices**: Check for adherence to:\n   - Proper error handling (try-catch, error propagation)\n   - Appropriate use of async/await\n   - Type safety (for TypeScript - avoid 'any', use proper types)\n   - Naming conventions (clear, descriptive names)\n   - Code organization and modularity\n   - SOLID principles\n   - DRY principle (Don't Repeat Yourself)\n\n4. **Readability**: Suggest improvements for:\n   - Code clarity\n   - Better variable/function names\n   - Clearer logic flow\n   - Appropriate comments (why, not what)\n   - Consistent formatting\n\n5. **Maintainability**: Identify areas that could be refactored to:\n   - Make code easier to maintain\n   - Improve extensibility\n   - Reduce coupling\n   - Increase cohesion\n\n6. **Performance**: Highlight potential optimizations:\n   - Unnecessary loops or iterations\n   - Inefficient algorithms\n   - Memory leaks\n   - Blocking operations\n   - Without sacrificing readability\n\n7. **Tests**: Ensure tests are actually testing functionnality and not implementation details:\n   - Check against requirements that tests are actually testing the functionnality\n   - Test must remain simple and avoid having complex logic that might itself have issues\n \n\n**Output Format**:\nFor each file with issues, provide:\n- File path\n- Severity (Critical/High/Medium/Low)\n- Issue category\n- Specific line numbers or code snippets\n- Clear explanation of the problem\n- Actionable suggestion for improvement\n- Example code if applicable\n- Was the issue already present before the change\n\nPrioritize the most impactful improvements. Ensure all suggestions maintain existing functionality."
  },
  "workspaceFolderName": "prompt-registry",
  "shortName": "branch-diff-reviewer"
}