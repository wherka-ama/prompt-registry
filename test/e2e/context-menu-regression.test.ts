/**
 * E2E Tests: Context Menu Regression Prevention
 * 
 * Tests that context menu options appear correctly for installed bundles
 * across all installation scopes. This prevents regressions where package.json
 * 'when' clauses don't match the context values generated by RegistryTreeProvider.
 * 
 * Requirements covered:
 * - 7.1: Verify installed bundles have expected context menu options
 * - 7.2: Verify context menu options work for user-scoped bundles
 * - 7.3: Verify context menu options work for repository-scoped bundles
 * - 7.4: Detect future regressions in context menu configuration
 * 
 * Properties validated:
 * - Property 1: Context Value Regex Matching
 * - Property 2: User Scope Menu Options
 * - Property 3: Repository Scope Menu Options
 */

import * as assert from 'assert';
import * as sinon from 'sinon';
import * as vscode from 'vscode';
import { RegistryTreeProvider, TreeItemType, RegistryTreeItem } from '../../src/ui/RegistryTreeProvider';
import { RegistryManager } from '../../src/services/RegistryManager';
import { HubManager } from '../../src/services/HubManager';
import { setupTreeProviderMocks, isValidContextValue, VALID_CONTEXT_PATTERNS_FOR_MENUS, validateContextPatterns } from '../helpers/uiTestHelpers';
import { InstalledBundle } from '../../src/types/registry';
import { createMockBundleDetails } from '../helpers/bundleTestHelpers';

/**
 * All base context values that should be recognized by package.json.
 * These correspond to the different states an installed bundle can be in.
 */
const BASE_CONTEXT_VALUES = [
    'installed_bundle_auto_disabled',
    'installed_bundle_auto_enabled',
    'installed_bundle_updatable_auto_disabled',
    'installed_bundle_updatable_auto_enabled'
] as const;

/**
 * All valid scope suffixes that can be appended to context values.
 * These are generated by RegistryTreeProvider.getContextValue().
 */
const SCOPE_SUFFIXES = [
    '_user',
    '_repository_commit',
    '_repository_local_only'
] as const;

suite('E2E: Context Menu Regression Prevention', () => {
    let provider: RegistryTreeProvider;
    let registryManagerStub: sinon.SinonStubbedInstance<RegistryManager>;
    let hubManagerStub: sinon.SinonStubbedInstance<HubManager>;
    let sandbox: sinon.SinonSandbox;

    /**
     * Creates a mock installed bundle with the specified scope configuration.
     */
    function createMockInstalledBundle(
        bundleId: string,
        scope: 'user' | 'repository',
        commitMode?: 'commit' | 'local-only'
    ): InstalledBundle {
        const bundle: InstalledBundle = {
            bundleId,
            version: '1.0.0',
            installedAt: new Date().toISOString(),
            scope,
            installPath: `/mock/${scope}/path`,
            manifest: {} as any
        };
        
        if (scope === 'repository' && commitMode) {
            bundle.commitMode = commitMode;
        }
        
        return bundle;
    }

    /**
     * Creates the installed bundles root tree item for testing.
     */
    function createInstalledRoot(): RegistryTreeItem {
        return new RegistryTreeItem(
            'Installed Bundles',
            TreeItemType.INSTALLED_ROOT,
            undefined,
            vscode.TreeItemCollapsibleState.Expanded
        );
    }

    /**
     * Sets up mocks for a single bundle and returns its tree item.
     */
    async function setupBundleAndGetTreeItem(bundle: InstalledBundle): Promise<RegistryTreeItem> {
        registryManagerStub.listInstalledBundles.resolves([bundle]);
        registryManagerStub.getBundleDetails.withArgs(bundle.bundleId).resolves(
            createMockBundleDetails(bundle.bundleId)
        );
        
        const items = await provider.getChildren(createInstalledRoot());
        assert.strictEqual(items.length, 1, 'Should have one installed bundle');
        return items[0];
    }

    setup(() => {
        sandbox = sinon.createSandbox();
        registryManagerStub = sandbox.createStubInstance(RegistryManager);
        hubManagerStub = sandbox.createStubInstance(HubManager);
        
        setupTreeProviderMocks(registryManagerStub, hubManagerStub, sandbox);
        provider = new RegistryTreeProvider(registryManagerStub as any, hubManagerStub as any);
    });

    teardown(() => {
        sandbox.restore();
    });

    suite('Property 1: Context Value Regex Matching', () => {
        /**
         * Validates: Requirements 1.1-1.4, 2.1-2.2, 3.1-3.4, 4.1-4.4, 6.2
         * 
         * For any base context value and any valid scope suffix,
         * the regex pattern in package.json should match the combined context value.
         */
        test('Requirement 6.2: all base context values with all scope suffixes should match valid patterns', () => {
            for (const baseValue of BASE_CONTEXT_VALUES) {
                for (const suffix of SCOPE_SUFFIXES) {
                    const contextValue = `${baseValue}${suffix}`;
                    
                    assert.ok(
                        isValidContextValue(contextValue),
                        `Context value '${contextValue}' should match a valid pattern in package.json. ` +
                        `This means menu items won't appear for bundles with this context value.`
                    );
                }
            }
        });

        test('Requirement 6.2: base context values without suffix should match base patterns', () => {
            // Base values without scope suffix should match the base patterns
            // (which use ^ anchor without $ anchor)
            for (const baseValue of BASE_CONTEXT_VALUES) {
                assert.ok(
                    isValidContextValue(baseValue),
                    `Base context value '${baseValue}' should match base patterns`
                );
            }
        });
    });

    suite('Property 2: User Scope Menu Options', () => {
        /**
         * Validates: Requirement 5.1
         * 
         * For any installed bundle with user scope, the context value should
         * match the patterns for scope-related menu options.
         */
        test('Requirement 7.2: user-scoped bundle should have valid context value for all menu options', async () => {
            const userBundle = createMockInstalledBundle('user-bundle-1', 'user');
            const item = await setupBundleAndGetTreeItem(userBundle);
            const contextValue = item.contextValue as string;
            
            // Verify context value is valid for menus
            assert.ok(
                isValidContextValue(contextValue),
                `User bundle context value '${contextValue}' should be valid for menu items`
            );
            
            // Verify it ends with _user suffix for scope-specific menus
            assert.ok(
                contextValue.endsWith('_user'),
                `User bundle context value '${contextValue}' should end with '_user'`
            );
            
            // Verify scope-specific pattern matches (for "Move to Repository" options)
            const userScopePattern = /^installed_bundle.*_user$/;
            assert.ok(
                userScopePattern.test(contextValue),
                `User bundle context value '${contextValue}' should match user scope pattern for "Move to Repository" menu options`
            );
        });

        test('Requirement 7.2: user-scoped bundle with update available should have valid context value', async () => {
            const userBundle = createMockInstalledBundle('user-bundle-updatable', 'user');
            
            registryManagerStub.listInstalledBundles.resolves([userBundle]);
            registryManagerStub.getBundleDetails.withArgs('user-bundle-updatable').resolves(
                createMockBundleDetails('user-bundle-updatable')
            );
            registryManagerStub.checkUpdates.resolves([{
                bundleId: 'user-bundle-updatable',
                currentVersion: '1.0.0',
                latestVersion: '2.0.0'
            }]);

            const items = await provider.getChildren(createInstalledRoot());
            const contextValue = items[0].contextValue as string;
            
            assert.ok(
                isValidContextValue(contextValue),
                `Updatable user bundle context value '${contextValue}' should be valid for menu items`
            );
        });
    });

    suite('Property 3: Repository Scope Menu Options', () => {
        /**
         * Validates: Requirements 5.2, 5.3, 5.4
         * 
         * For any installed bundle with repository scope, the context value should
         * match the patterns for scope-related menu options based on commit mode.
         */
        test('Requirement 7.3: repository-scoped bundle (commit mode) should have valid context value', async () => {
            const repoBundle = createMockInstalledBundle('repo-bundle-commit', 'repository', 'commit');
            const item = await setupBundleAndGetTreeItem(repoBundle);
            const contextValue = item.contextValue as string;
            
            // Verify context value is valid for menus
            assert.ok(
                isValidContextValue(contextValue),
                `Repository commit bundle context value '${contextValue}' should be valid for menu items`
            );
            
            // Verify it ends with _repository_commit suffix
            assert.ok(
                contextValue.endsWith('_repository_commit'),
                `Repository commit bundle context value '${contextValue}' should end with '_repository_commit'`
            );
            
            // Verify pattern for "Move to User" and "Switch to Local Only" options
            const repoCommitPattern = /^installed_bundle.*_repository_commit$/;
            assert.ok(
                repoCommitPattern.test(contextValue),
                `Repository commit bundle context value '${contextValue}' should match commit mode pattern`
            );
        });

        test('Requirement 7.3: repository-scoped bundle (local-only mode) should have valid context value', async () => {
            const repoBundle = createMockInstalledBundle('repo-bundle-local', 'repository', 'local-only');
            const item = await setupBundleAndGetTreeItem(repoBundle);
            const contextValue = item.contextValue as string;
            
            // Verify context value is valid for menus
            assert.ok(
                isValidContextValue(contextValue),
                `Repository local-only bundle context value '${contextValue}' should be valid for menu items`
            );
            
            // Verify it ends with _repository_local_only suffix (note: 'local-only' becomes 'local_only')
            assert.ok(
                contextValue.endsWith('_repository_local_only'),
                `Repository local-only bundle context value '${contextValue}' should end with '_repository_local_only'`
            );
            
            // Verify pattern for "Move to User" and "Switch to Commit" options
            const repoLocalOnlyPattern = /^installed_bundle.*_repository_local_only$/;
            assert.ok(
                repoLocalOnlyPattern.test(contextValue),
                `Repository local-only bundle context value '${contextValue}' should match local-only mode pattern`
            );
        });

        test('Requirement 7.3: repository-scoped bundles should match combined repository pattern', async () => {
            const commitBundle = createMockInstalledBundle('repo-commit', 'repository', 'commit');
            const localOnlyBundle = createMockInstalledBundle('repo-local', 'repository', 'local-only');
            
            registryManagerStub.listInstalledBundles.resolves([commitBundle, localOnlyBundle]);
            registryManagerStub.getBundleDetails.withArgs('repo-commit').resolves(
                createMockBundleDetails('repo-commit')
            );
            registryManagerStub.getBundleDetails.withArgs('repo-local').resolves(
                createMockBundleDetails('repo-local')
            );

            const items = await provider.getChildren(createInstalledRoot());
            assert.strictEqual(items.length, 2, 'Should have two installed bundles');
            
            // Both should match the combined repository pattern for "Move to User" option
            const combinedRepoPattern = /^installed_bundle.*_repository_(commit|local_only)$/;
            
            for (const item of items) {
                const contextValue = item.contextValue as string;
                assert.ok(
                    combinedRepoPattern.test(contextValue),
                    `Repository bundle context value '${contextValue}' should match combined repository pattern`
                );
            }
        });
    });

    suite('Regression Detection', () => {
        /**
         * Validates: Requirement 7.4
         * 
         * If a future change breaks the context menu configuration,
         * these tests should fail and alert developers to the regression.
         */
        test('Requirement 7.4: all scope combinations should produce valid context values', async () => {
            const testCases: Array<{ scope: 'user' | 'repository'; commitMode?: 'commit' | 'local-only' }> = [
                { scope: 'user' },
                { scope: 'repository', commitMode: 'commit' },
                { scope: 'repository', commitMode: 'local-only' }
            ];
            
            for (const testCase of testCases) {
                const bundleId = `test-bundle-${testCase.scope}-${testCase.commitMode || 'default'}`;
                const bundle = createMockInstalledBundle(bundleId, testCase.scope, testCase.commitMode);
                const item = await setupBundleAndGetTreeItem(bundle);
                const contextValue = item.contextValue as string;
                
                assert.ok(
                    isValidContextValue(contextValue),
                    `REGRESSION DETECTED: Context value '${contextValue}' for ${testCase.scope} scope ` +
                    `${testCase.commitMode ? `(${testCase.commitMode} mode)` : ''} ` +
                    `is not recognized by package.json. Menu items will not appear!`
                );
            }
        });

        test('Requirement 7.4: valid patterns array should include all necessary patterns', () => {
            // Check that we have at least the minimum number of patterns
            assert.ok(
                VALID_CONTEXT_PATTERNS_FOR_MENUS.length >= 5,
                `Should have at least 5 patterns for all menu scenarios, got ${VALID_CONTEXT_PATTERNS_FOR_MENUS.length}`
            );
            
            // Verify specific patterns exist for each menu scenario
            const hasBasePatterns = VALID_CONTEXT_PATTERNS_FOR_MENUS.some(p => 
                p.source.startsWith('^installed_bundle_auto_') && !p.source.endsWith('$')
            );
            const hasUserPattern = VALID_CONTEXT_PATTERNS_FOR_MENUS.some(p => 
                p.source.includes('_user$')
            );
            const hasRepoCommitPattern = VALID_CONTEXT_PATTERNS_FOR_MENUS.some(p => 
                p.source.includes('_repository_commit$')
            );
            const hasRepoLocalOnlyPattern = VALID_CONTEXT_PATTERNS_FOR_MENUS.some(p => 
                p.source.includes('_repository_local_only$')
            );
            
            assert.ok(hasBasePatterns, 'Should have base context value patterns (for Update, Check Updates, Auto-Update, Uninstall menus)');
            assert.ok(hasUserPattern, 'Should have user scope pattern (for Move to Repository menus)');
            assert.ok(hasRepoCommitPattern, 'Should have repository commit pattern (for Switch to Local Only menu)');
            assert.ok(hasRepoLocalOnlyPattern, 'Should have repository local-only pattern (for Switch to Commit menu)');
        });
    });

    suite('Package.json Pattern Synchronization', () => {
        /**
         * Validates: Requirements 1.2, 1.3, 1.4, 1.5 from e2e-test-quality-fixes spec
         * 
         * This test ensures that VALID_CONTEXT_PATTERNS_FOR_MENUS in uiTestHelpers.ts
         * stays synchronized with the actual when clauses in package.json.
         * 
         * If someone updates package.json and forgets to update the test helper,
         * this test will fail with a descriptive error message.
         */
        test('VALID_CONTEXT_PATTERNS_FOR_MENUS should match package.json when clauses', () => {
            const result = validateContextPatterns();
            
            if (!result.valid) {
                const messages: string[] = [];
                
                if (result.missingInHelper.length > 0) {
                    messages.push(
                        `Patterns in package.json but missing from VALID_CONTEXT_PATTERNS_FOR_MENUS:\n` +
                        result.missingInHelper.map(p => `  - /${p}/`).join('\n') +
                        `\n\nAdd these patterns to VALID_CONTEXT_PATTERNS_FOR_MENUS in test/helpers/uiTestHelpers.ts`
                    );
                }
                
                if (result.extraInHelper.length > 0) {
                    messages.push(
                        `Patterns in VALID_CONTEXT_PATTERNS_FOR_MENUS but not in package.json:\n` +
                        result.extraInHelper.map(p => `  - /${p}/`).join('\n') +
                        `\n\nRemove these patterns from VALID_CONTEXT_PATTERNS_FOR_MENUS or add them to package.json`
                    );
                }
                
                assert.fail(
                    `PATTERN SYNCHRONIZATION FAILURE\n\n` +
                    `The test helper patterns don't match package.json when clauses.\n` +
                    `This means context menu tests may pass even when actual menus are broken.\n\n` +
                    messages.join('\n\n')
                );
            }
        });
    });
});
